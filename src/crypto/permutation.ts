/**
 * Creates a simple seeded pseudo-random number generator (Mulberry32).
 * @param seed A 32-bit integer seed.
 * @returns A function that returns the next pseudo-random number between 0 (inclusive) and 1 (exclusive).
 */
function mulberry32(seed: number) {
  return function() {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}

/**
 * Converts a Uint8Array seed into a 32-bit integer seed.
 * Simple approach: XOR bytes together. More robust methods exist.
 */
function seedToInt32(seedBytes: Uint8Array): number {
    let seedInt = 0;
    for (let i = 0; i < seedBytes.length; i++) {
        // Combine bytes, shifting and XORing to mix bits
        seedInt = (seedInt << 8) | (seedInt >>> 24); // Rotate left by 8 bits
        seedInt ^= seedBytes[i];
    }
    return seedInt | 0; // Ensure it's treated as a 32-bit integer
}


/**
 * Generates a permutation of numbers [0, 1, ..., n-1] based on a seed.
 * Uses Fisher-Yates shuffle algorithm with a seeded PRNG.
 *
 * @param seedBytes The seed material (e.g., derived key material).
 * @param n The size of the permutation array (number of elements to shuffle).
 * @returns An array representing the permutation. perm[i] is the new position of element i.
 */
export function generatePermutation(seedBytes: Uint8Array, n: number): number[] {
  if (n <= 0) {
    return [];
  }

  const seedInt = seedToInt32(seedBytes);
  const random = mulberry32(seedInt);

  // Initialize array [0, 1, ..., n-1]
  const p: number[] = new Array(n);
  for (let i = 0; i < n; i++) {
    p[i] = i;
  }

  // Fisher-Yates (Knuth) Shuffle
  for (let i = n - 1; i > 0; i--) {
    const j = Math.floor(random() * (i + 1)); // 0 <= j <= i
    // Swap p[i] and p[j]
    [p[i], p[j]] = [p[j], p[i]];
  }

  // The result 'p' is the shuffled array where p[i] is the value originally at index i.
  // The spec seems to imply pi_K(i) is the *new index* for the element originally at index i.
  // Let's create the inverse permutation map for easier application: permMap[originalIndex] = newIndex
  // No, the spec says c'_i = c_{\pi_K(i)}. This means the value at the *new* index i comes
  // from the value at the *original* index pi_K(i).
  // So, if p = [2, 0, 1] after shuffle (n=3), it means:
  // - original 0 went to index 1
  // - original 1 went to index 2
  // - original 2 went to index 0
  // We want pi_K such that c'_i = c_{pi_K(i)}.
  // c'_0 = c_{pi_K(0)} => element originally at pi_K(0) moves to index 0. From shuffle p, element 2 moved to index 0. So pi_K(0) = 2.
  // c'_1 = c_{pi_K(1)} => element originally at pi_K(1) moves to index 1. From shuffle p, element 0 moved to index 1. So pi_K(1) = 0.
  // c'_2 = c_{pi_K(2)} => element originally at pi_K(2) moves to index 2. From shuffle p, element 1 moved to index 2. So pi_K(2) = 1.
  // So, the desired pi_K is the array 'p' generated by the shuffle directly.

  return p;
}

/**
 * Applies a permutation to an array.
 * result[i] = source[permutation[i]]
 */
export function applyPermutation<T>(source: T[], permutation: number[]): T[] {
    if (source.length !== permutation.length) {
        throw new Error("Source array and permutation must have the same length.");
    }
    const n = source.length;
    const result = new Array<T>(n);
    for (let i = 0; i < n; i++) {
        const sourceIndex = permutation[i];
        if (sourceIndex < 0 || sourceIndex >= n) {
             throw new Error(`Invalid index ${sourceIndex} in permutation for length ${n}.`);
        }
        result[i] = source[sourceIndex];
    }
    return result;
}

/**
 * Applies the inverse of a permutation to an array.
 * result[permutation[i]] = source[i]
 */
export function applyInversePermutation<T>(source: T[], permutation: number[]): T[] {
    if (source.length !== permutation.length) {
        throw new Error("Source array and permutation must have the same length.");
    }
    const n = source.length;
    const result = new Array<T>(n);
    for (let i = 0; i < n; i++) {
        const targetIndex = permutation[i];
         if (targetIndex < 0 || targetIndex >= n) {
             throw new Error(`Invalid index ${targetIndex} in permutation for length ${n}.`);
        }
        result[targetIndex] = source[i];
    }
    return result;
}
